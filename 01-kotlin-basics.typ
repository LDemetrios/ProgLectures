#import "kotlinheader.typ" : *
#import "tablex.typ": tablex, rowspanx, colspanx, hlinex, vlinex

#set par(justify: true)

#let func = ["he-he"]

// TODO : show rule for JVM, JS, Kotlin, Java, C++ icon

Будем пользоваться нотацией REPL: после `=>` описывается тип результата, затем
строковое представление результата. Если код что-то выводит, то это написано
после результата.

Итак, Котлин. Давайте для начала разберёмся с местными примитивными
конструкциями. У нас есть следующие типы данных:

#let prim(code, repr: none, typ) = {
  indent(kt-literal(code.text, typ))
  kt-res(if (repr == none) { code } else { repr }, typ)
}

- Логические значения
#prim(`true`, KtBool)

- Целые числа (32-битные в two's complement)
#prim(`566`, KtInt)

- Длинные целые числа (64-битные)
#prim(`566L`, repr: `566`, KtLong)

- Строки
#prim(`"Hello"`, KtString)

- Символы
#prim(`'a'`, KtChar)

- Вещественные числа (Стандарт `IEEE-754`, double precision floating point number)
#prim(`3.14`, KtDouble)

#kt-par[
  Все эти типы заимствованы из JVM. Собственно, из неё же заимствованы ещё и типы
  Byte (8-битное целое), Short (16-битное целое) и Float (single-precision
  вещественное), но их используют крайне редко (поскольку всё меньше остаётся даже
  32-битных процессоров).

  Зато, для желающих, есть _довольно быстрая_ реализация `unsigned` целых чисел:
  `UInt`, `ULong` etc.
]

С этими типами можно делать довольно ожидаемые действия:

- Складывать:
#kt-eval(``` 0.1 + 0.2 ```)
#kt-res(`0.30000000000000004`, KtDouble)

- Умножать:
#kt-eval(``` 5 * -2 ```)
#kt-res(`-10`, KtInt)

- Делить:
#kt-eval(``` 1.0 / 0.0 ```)
#kt-res(`Infinity`, KtDouble)

#kt-par[
  Без неожиданных спецэффектов. Автоприведения типов здесь нет, так что
  #raw("\"22\" - \"2\" = 20"),
  как в JS, не получится. С символами, впрочем, операции производить можно:
]

#kt-eval(``` 'c' - 'a' ```)
#kt-res(`2`, KtInt)

Также в наличии логические операции

#kt-eval(``` !false ```)
#kt-res(`true`, KtBool)
#kt-eval(``` true && false ```)
#kt-res(`false`, KtBool)

Ну и так далее. Разберётесь по ходу ведения.

Ветвление:
#kt-eval(```
if (1 + 2 < 4) {
    println("First")
} else {
    println("Second")
}
```)
#kt-res(KtUnit, KtUnit)
#kt-print(`First`)

#kt-par[
  О, здесь сразу несколько интересных вещей: println отвечает за вывод строки в
  stdout (стандартный поток вывода). А Unit --- это тип, который возвращается,
  если не возвращается ничего. Есть в Котлине два таких интересных типа: Unit ---
  когда единственное, что нам нужно знать --- это завершилась функция или нет.
  Если завершилась, то возвращается Unit --- единственное значение типа Unit. Ну,
  содержательного с ним ничего нельзя сделать --- только сказать, что он есть.
  Второй --- Nothing --- означает, что функция никогда ничего не вернёт, потому
  что не завершится успешно. Если у предыдущего типа существует единственное
  значение, то у типа Nothing нет ни одного значения.

  Так, погодите. Выходит, у нас `if...else` что-то возвращает? А можно, чтобы он
  возвращал содержательную информацию? Можно.
]

#kt-eval(```
if (1 + 2 < 4) {
    // Do something
    566
} else {
    // Do some another thing
    239
}
```)
#kt-res(``` 566 ```, KtInt)

#kt-par[
  Последняя строчка интерпретируется как выражение --- то есть, что-то-таки
  возвращает наружу. Собственно, привычный многим в Java и в C++ тернарный
  оператор ` a ? b : c ` здесь так и сделан: если выражение однострочное, то
  фигурные скобки можно и не ставить.\
]

#kt-eval(``` if(1 + 2 < 4) 566 else 239 ```)
#kt-res(``` 566 ```, KtInt)

Теперь циклы. А для циклов сначала нужны переменные. Их есть:

#kt-eval(```
var i = 0
while (i < 5) {
    print(i)
    i++
}
```)
#kt-print(``` 01234 ```)

#kt-par[
  Во-первых, print --- это как println, только без перевода строки. Во-вторых,
  погодите, а результат? Мы думали, и в магазине можно стеночку приподнять?

  А нет. Цикл не является выражением, он не возвращает даже Unit. Как, впрочем, и
  объявление переменной.

  В-третьих, переменные в Котлине имеют тип. То есть, если у вас про переменную
  заявлено, что там лежат числа, вы не можете положить туда строку:
]

#kt-eval(```
var a : Int = 0
a = 1
a = "2"
```)
#kt-comp-err(`Kotlin: Type mismatch: inferred type is String but Int was expected`)

#kt-par[
  А если вы не заявляли тип явно, то компилятор сам выведет наиболее узкий,
  который сможет.

  Кроме переменных, конечно, есть постоянные:
]

#kt-eval(```
val a : Int = 0
a = 1
```)
#kt-comp-err(`Kotlin: Val cannot be reassigned`)

#kt-par[
  Если вы можете использовать val, используйте val, а не var.

  Есть также циклы do-while:
]

#kt-eval-noret(```
do {
    val line = readln()
    // Do something with it
} while (line != "exit")
```)

#kt-par[
  Переменная, объявленная внутри цикла, в общем случае снаружи не видна, а вот в
  случае конкретно do-while видна в условии, что приятно. Кажется, так было не
  всегда.

  ... и циклы for:
]

#kt-eval(```
for (i in 0 until 5) {
    print(i)
}
```)
#kt-print(``` 01234 ```)

#kt-par[
  until --- это специальная инфиксная функция, которая возвращает арифметическую
  прогрессию, от первого аргумента включительно, до второго исключительно. Что
  означает "инфиксная"? Ну, функции в котлине бывают трёх различных вариантов:
  префиксная (#kt(`cos(1.0)`)), условно-постфиксная (#kt(`566.toString()`)) и
  инфиксная (#kt(`0 until 5`)). _Условно_-постфиксные они потому, что в скобках
  могут быть ещё аргументы, например, #kt(`566.toString(3)`), чтобы преобразовать
  в троичную систему счисления. Все инфиксные функции можно вызывать также и в
  условно-постфиксной записи: #kt(`0.until(5)`), но не наоборот.

  Помимо until есть ещё downTo и rangeTo:
]

#table(
  columns: (auto, auto, auto, auto),
  rows: 2em,
  align: center + horizon,
  [until],
  kt(`0 until 5`),
  kt(`0.until(5)`),
  `[0, 1, 2, 3, 4]`,
  [rangeTo],
  kt(`0..5`),
  kt(`0.rangeTo(5)`),
  `[0, 1, 2, 3, 4, 5]`,
  [downTo],
  kt(`5 downTo 0`),
  kt(`5.downTo(0)`),
  `[5, 4, 3, 2, 1, 0]`,
)

#kt-par[
  В экспериментальных на момент написания конспекта версиях Котлина есть ещё
  вариант #kt(`0..<5`) для until.

  Как это работает? Э-хе-хе, подождите, давайте сначала научимся префиксные
  функции писать.
]

#kt(```
fun max(a: Int, b: Int): Int
```)

#kt-par[
  Что бы всё это значило? fun собственно объявляет функцию. `a` и `b` --- это
  имена параметров, после них написаны их типы (Int), а после двоеточия после
  всего объявления тип того, что возвращает функция. В нашем случае функция
  принимает два аргумента типа Int и возвращает тоже Int. Теперь собственно, что
  делает эта функция?
]

#kt-eval(```
fun max(a: Int, b: Int): Int {
    if (a < b) {
        return b
    } else {
        return a
    }
}
```)

Ну, здесь всё понятно.

Проверим, что работает:

#kt-eval(``` max(239, 566) ```)
#kt-res(`566`, KtInt)

#kt-par[
  Ещё не забыли, что if у нас также является тернарным оператором?
]

#kt-eval(```
    fun max(a: Int, b: Int): Int {
        return if (a < b) b else a
    }    ```)

#kt-par[
  Если тело функции состоит только из return-statement, то фигурные скобки и
  return не нужны, вместо них пишем
]

#kt-eval(```
    fun max(a: Int, b: Int): Int = if (a < b) b else a
    ```)

#kt-par[
  Здесь уже можно опустить возвращаемый тип, ибо он очевиден компилятору, но лучше
  всё же писать.
]

#kt-par[
  Так, кроме того, мы ввели ключевое слово return. Кроме него существуют ещё такие
  интересные штуки как break, continue и throw, которые делают понятно что. Но их
  объединяет следующая черта: после них точно будет выполняться уже не эта строка.
  В некотором смысле, это выражение никогда ничего не возвращает. О, где-то такое
  уже было. На самом деле на уровне языка оно возвращает тип Nothing. Например,
  если мы напишем
]
#kt(`val x = return`)
#kt-par[, то понятно, что до присвоения значения постоянной `x` дело так и не дойдёт.

  Для понимания следующего сначала рассмотрим обобщающие типы. Так, если мы пишем]
#kt(`if(condition) 1 else 2`)
#kt-par[, то понятно, какой тип выведет компилятор --- Int. А если типы возвращаемых
  данных разные? Ошибка?]

#kt-eval(```
    if(1 < 2) 3 else "4"
    ```)
#kt-res(`3`, Comparable(KtStar))

#kt-par[
  А нет. Что-то мы всё же про это знаем, и числа, и строки можно сравнивать. А
  значит, мы на выходе получили что-то _сравниваемое_ (#Comparable(KtStar)). Что
  означает звёздочка в треугольных скобках --- мы потом разберём, сейчас это
  несущественно. А бывают типы данных, которые нельзя сравнивать? Бывают, например
  Unit. Ну, его сравнивать довольно бесполезно --- он всегда окажется равен самому
  себе, поскольку единственное, что существует типа Unit --- это Unit сам по себе.
]

#kt-eval(```
    if(1 < 2) 3 else Unit
    ```)
#kt-res(`3`, Any)

#kt-par[
  Вот Any --- это почти самый общий тип. Он означает "ну, что-то там определённо
  лежит". С ним можно проделать не так много вещей:
  - потребовать строковое представление
  - посчитать хэшкод
  - сравнить на равенство с чем-то другим.
  В общем-то, всё.

  Есть ещё значение null, которое не является Any, а о его типе поговорим чуть
  позже.

  Так вот, всё, что не null --- является Any, и может быть приведён к типу Any. А
  тип Nothing --- наоборот, может быть приведён *_к_* любому типу. Потому что на
  самом деле никогда не понадобится приводить, потому что объектов типа Nothing не
  существует.

  Значение null в Котлине несёт тот же смысл, что null в Java, nullptr в С++, None
  в Python и т.д. Это заглушка, возможность сказать, что здесь могло бы быть
  значение, но пока его нет. Но хранить их можно только в специальных nullable
  типах, помечаемых знаком вопроса.
]

#strikeleft[
  #kt-eval(```
        var s : String = "abc"
        s = null
        ```)
  #kt-comp-err(`Null can not be a value of a non-null type String`)

  #kt-eval(```
        var s : String? = "abc"
        s = null // OK
        ```)
]

#kt-par[
  В отличие от Java, nullable типами могут быть и примитивные (Int, Long etc.).
  #comment[
    Впрочем, это довольно неэффективно, так как, в то время как Int, Char, и так
    далее транслируются в использование примитивов (int, char), nullable типы Int?,
    Char? --- в объектные Integer, Character и так далее, чтобы можно было
    присваивать им null. Это занимает больше места, больше времени и прочее.
    Аналогично происходит с lateinit var, которые под капотом nullable.
  ]
  Поскольку NullPointerException --- одна из самых частых ошибок времени
  исполнения в Java, в Kotlin добавили специальных операторов для работы с
  nullable значениями:
]

- Non-null assertion
#strikeleft[
  #kt-par[
    Если значение не null, то вернуть его, если null --- бросить ошибку.
  ]

  #kt-eval(```
        val s : String? = "abacaba"
        s!!
        ```)
  #kt-res(`"abacaba"`, KtString)

  #kt-eval(```
        val s : String? = null
        s!!
        ```)
  #kt-runt-err(```
        Exception in thread "main" java.lang.NullPointerException
          at test.TestKts.main(Test.kts:2)
        ```)
]
- Safe call
#strikeleft[
  #kt-par[
    Если значение не null, то вызвать метод, если null --- вернуть null.
  ]

  #kt-eval(```
        val s : String? = "abacaba"
        s?.substring(2, 6)
        ```)
  #kt-res(`"acab"`, `String?`)

  #kt-eval(```
        val s : String? = null
        s?.substring(2, 6)
        ```)
  #kt-res(`null`, `String?`)
]

- Elvis operator

#strikeleft[
  #kt-par[
    Если значение не null, то вернуть его, если null --- то вернуть другое.
  ]

  #kt-eval(```
          val s : String? = "abacaba"
          s ?: "by default"
          ```)
  #kt-res(`"abacaba"`, `String`)

  #kt-eval(```
          val s : String? = null
          s ?: "by default"
          ```)
  #kt-res(`"by default"`, `String`)
]
#kt-par[
  Какой тип имеет сам null?
]

#kt-eval(`null`)
#kt-res(`null`, `Nothing?`)

#kt-par[
  Почему так? Логично, что если тип `T` приводится к типу `U`, то тип `T?` должен
  приводиться к типу `U?` (Если там было значение типа `T`, то его можно положить
  в `U`, а значит, в `U?` тем более. А если там был null, то его всё равно можно
  положить в `U?`). И логично, чтобы null приводился к любому nullable типу.
  Nothing приводится к любому `T`, значит, Nothing? приводится к любому `T?`.
]
