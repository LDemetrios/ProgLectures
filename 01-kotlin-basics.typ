#import "kotlinheader.typ" : *

#import "kotlin-std-types.typ" : *

#show : kt-show-rules

// TODO : show rule for JVM, JS, Kotlin, Java, C++ icon
//TODO
#let kt-ea(code) = {
  kt-eval-alone(code)
  kt-alone(code)
}

Будем пользоваться нотацией REPL: после ```=>``` описывается тип результата,
затем строковое представление результата. Если код что-то выводит, то это
написано после результата.

Итак, Котлин. Давайте для начала разберёмся с местными примитивными
конструкциями. У нас есть следующие типы данных:

#let prim(code, repr: none, type) = {
  kt-ea(code)
  kt-res(if (repr == none) { code } else { repr }, type)
}

- Логические значения
#prim(``` true ```, KtBool)

- Целые числа (32-битные в two's complement)
#prim(``` 566 ```, KtInt)

- Длинные целые числа (64-битные)
#prim(``` 566L ```, repr: ``` 566 ```, KtLong)

- Строки
#prim(``` "Hello" ```, KtString)

- Символы
#prim(``` 'a' ```, KtChar)

- Вещественные числа (Стандарт `IEEE-754`, double precision floating point
  number)
#prim(``` 3.14 ```, KtDouble)

#kt-par[
  Все эти типы заимствованы из JVM. Собственно, из неё же заимствованы ещё и типы
  Byte (8-битное целое), Short (16-битное целое) и Float (single-precision
  вещественное), но их используют крайне редко (поскольку всё меньше остаётся даже
  32-битных процессоров).

  Зато, для желающих, есть _довольно быстрая_ реализация `unsigned` целых
  чисел: `UInt`, `ULong` etc.
]

С этими типами можно делать довольно ожидаемые действия:

- Складывать:
#kt-ea(``` 0.1 + 0.2 ```)
#kt-res(``` 0.30000000000000004 ```, KtDouble)

- Умножать:
#kt-ea(``` 5 * -2 ```)
#kt-res(``` -10 ```, KtInt)

- Делить:
#kt-ea(```  1.0 / 0.0 ```)
#kt-res(``` Infinity ```, KtDouble)

#kt-par[
  Без неожиданных спецэффектов. Автоприведения типов здесь нет, так что `"22" -
  "2" = 20 `, как в JS, не получится. С символами, впрочем, операции производить
  можно:
]
#kt-ea(```  'c' - 'a' ```)
#kt-res(``` 2 ```, KtInt)

Также в наличии логические операции

#kt-ea(```  !false ```)
#kt-res(``` true ```, KtBool)
#kt-ea(```  true && false ```)
#kt-res(``` false ```, KtBool)

Ну и так далее. Разберётесь по ходу ведения.

Ветвление:
#kt-ea(``` 
if (1 + 2 < 4) {
    println("First")
} else {
    println("Second")
}
```)
#kt-res(KtUnit, KtUnit)
#kt-print(``` First ```)

#kt-par[
  О, здесь сразу несколько интересных вещей: println отвечает за вывод строки в
  stdout (стандартный поток вывода). А Unit --- это тип, который возвращается,
  если не возвращается ничего. Есть в Котлине два таких интересных типа: Unit ---
  когда единственное, что нам нужно знать --- это завершилась функция или нет.
  Если завершилась, то возвращается Unit --- единственное значение типа Unit. Ну,
  содержательного с ним ничего нельзя сделать --- только сказать, что он есть.
  Второй --- Nothing --- означает, что функция никогда ничего не вернёт, потому
  что не завершится успешно. Если у предыдущего типа существует единственное
  значение, то у типа Nothing нет ни одного значения.

  Так, погодите. Выходит, у нас ` if...else ` что-то возвращает? А можно,
  чтобы он возвращал содержательную информацию? Можно.
]

#kt-ea(``` 
if (1 + 2 < 4) {
    // Do something
    566
} else {
    // Do some another thing
    239
}
```)
#kt-res(``` 566 ```, KtInt)

#kt-par[
  Последняя строчка интерпретируется как выражение --- то есть, что-то-таки
  возвращает наружу. Собственно, привычный многим в Java и в C++ тернарный
  оператор ` a ? b : c ` здесь так и сделан: если выражение однострочное, то
  фигурные скобки можно и не ставить.\
]

#kt-ea(``` if(1 + 2 < 4) 566 else 239 ```)
#kt-res(``` 566 ```, KtInt)

Теперь циклы. А для циклов сначала нужны переменные. Их есть:\
#kt-ea(``` 
var i = 0
while (i < 5) {
    print(i)
    i++
}
```)
#kt-print(``` 01234 ```)

#kt-par[
  Во-первых, print --- это как println, только без перевода строки. Во-вторых,
  погодите, а результат? Мы думали, и в магазине можно стеночку приподнять?

  А нет. Цикл не является выражением, он не возвращает даже Unit. Как, впрочем, и
  объявление переменной.

  В-третьих, переменные в Котлине имеют тип. То есть, если у вас про переменную
  заявлено, что там лежат числа, вы не можете положить туда строку:
]

#kt-ea(``` 
var a : Int = 0
a = 1
a = "2"
```)
#kt-comp-err(
  `Kotlin: Type mismatch: inferred type is String but Int was expected`,
)

А если вы не заявляли тип явно, то компилятор сам выведет наиболее узкий,
который сможет.

Кроме переменных, конечно, есть постоянные:

#kt-ea(``` 
val a : Int = 0
a = 1
```)
#kt-comp-err(`Kotlin: Val cannot be reassigned`)

#kt-par[
  Если вы можете использовать val, используйте val, а не var.

  Есть также циклы do-while:
]

#kt-ea(``` 
do {
    val line = readln()
    // Do something with it
} while (line != "exit")
```)
#kt-par[
  Переменная, объявленная внутри цикла, в общем случае снаружи не видна, а вот в
  случае конкретно do-while видна в условии, что приятно. Кажется, так было не
  всегда.
]

... и циклы for:
#kt-ea(``` 
for (i in 0 until 5) {
    print(i)
}
```)
#kt-print(``` 01234 ```)
until --- это специальная инфиксная функция, которая возвращает арифметическую
прогрессию, от первого аргумента включительно, до второго исключительно. Что
означает "инфиксная"? Ну, функции в котлине бывают трёх различных вариантов:
префиксная (#kt-fmt(```cos(1.0)```)), условно-постфиксная (#kt-fmt(```566.toString()```))
и инфиксная (#kt-fmt(```0 until 5```)). _Условно_-постфиксные они потому, что в
скобках могут быть ещё аргументы, например, #kt-fmt(```566.toString(3)```),
чтобы преобразовать в троичную систему счисления. Все инфиксные функции можно
вызывать также и в условно-постфиксной записи: #kt-fmt(```0.until(5)```), но не
наоборот.

Помимо until есть ещё downTo и rangeTo:

#table(
  columns: (auto, auto, auto, auto),
  rows: 2em,
  align: center + horizon,
  [until],
  kt-fmt(```0 until 5```),
  kt-fmt(```0.until(5)```),
  ```[0, 1, 2, 3, 4]```,
  [rangeTo],
  kt-fmt(```0..5```),
  kt-fmt(```0.rangeTo(5)```),
  ```[0, 1, 2, 3, 4, 5]```,
  [downTo],
  kt-fmt(```5 downTo 0```),
  kt-fmt(```5.downTo(0)```),
  ```[5, 4, 3, 2, 1, 0]```,
)

В экспериментальных на момент написания конспекта версиях Котлина есть ещё
вариант #kt-fmt(```0..<5```) для until.

Как это работает? Э-хе-хе, подождите, давайте сначала научимся префиксные
функции писать.

#kt-fmt(```
fun max(a: Int, b: Int): Int
```)

Что бы всё это значило? #kt-fmt(```fun```) собственно объявляет функцию. ```a```
и ```b``` --- это имена параметров, после них написаны их типы (#KtInt), а после
двоеточия после всего объявления тип того, что возвращает функция. В нашем
случае функция принимает два аргумента типа #KtInt и возвращает тоже #KtInt.
Теперь собственно, что делает эта функция?

#kt-ea(``` 
fun max(a: Int, b: Int): Int {
    if (a < b) {
        return b
    } else {
        return a
    }
}
```)

Ну, здесь всё понятно. Проверим, что работает:

#kt-ea(``` max(239, 566) ```)
#kt-res(``` 566 ```, KtInt)

Ещё не забыли, что if у нас также является тернарным оператором?

#kt-ea(``` 
fun max(a: Int, b: Int): Int {
    return if (a < b) b else a
}
```)

Если тело функции состоит только из return-statement, то фигурные скобки и
return не нужны, вместо них пишем

#kt-ea(``` 
fun max(a: Int, b: Int): Int = if (a < b) b else a
```)

Здесь уже можно опустить возвращаемый тип, ибо он очевиден компилятору, но лучше
всё же писать.

Так, кроме того, мы ввели ключевое слово return. Кроме него существуют ещё такие
интересные штуки как break, continue и throw, которые делают понятно что. Но их
объединяет следующая черта: после них точно будет выполняться уже не эта строка.
В некотором смысле, это выражение никогда ничего не возвращает. О, где-то такое
уже было. На самом деле на уровне языка оно возвращает тип Nothing. Например,
если мы напишем #kt-fmt(`val x = return`), то понятно, что до присвоения
значения постоянной `x` дело так и не дойдёт.

Для понимания следующего сначала рассмотрим обобщающие типы. Так, если мы пишем #kt-fmt(```if(condition) 1 else 2```),
то понятно, какой тип выведет компилятор --- #KtInt. А если типы возвращаемых
данных разные? Ошибка?
#kt-ea(``` 
if(1 < 2) 3 else "4"
```)
#kt-res(``` 3```, Comparable(KtStar))
А нет. Что-то мы всё же про это знаем, и числа, и строки можно сравнивать. А
значит, мы на выходе получили что-то _сравниваемое_ (#Comparable(KtStar)). Что
означает звёздочка в треугольных скобках --- мы потом разберём, сейчас это
несущественно. А бывают типы данных, которые нельзя сравнивать? Бывают, например #KtUnit.
Ну, его сравнивать довольно бесполезно --- он всегда окажется равен самому себе,
поскольку единственное, что существует типа #KtUnit --- это #KtUnit сам по себе. #kt-ea(``` 
if(1 < 2) 3 else Unit
```)
#kt-res(``` 3```, Any)
Вот #Any --- это почти самый общий тип. Он означает "ну, что-то там определённо
лежит". С ним можно проделать не так много вещей:
- потребовать строковое представление
- посчитать хэшкод
- сравнить на равенство с чем-то другим.
В общем-то, всё.

Есть ещё значение null, которое не является Any, а о его типе поговорим чуть
позже.

Так вот, всё, что не null --- является Any, и может быть приведён к типу Any. А
тип Nothing --- наоборот, может быть приведён *_к_* любому типу. Потому что на
самом деле никогда не понадобится приводить, потому что объектов типа Nothing не
существует.

Значение null в Котлине несёт тот же смысл, что null в Java, nullptr в С++, None
в Python и т.д. Это заглушка, возможность сказать, что здесь могло бы быть
значение, но пока его нет. Но хранить их можно только в специальных nullable
типах, помечаемых знаком вопроса.
#kt-ea(``` 
var s : String = "abc"
s = null
```)
#kt-comp-err(```Null can not be a value of a non-null type String```)

#kt-ea(``` 
var s : String? = "abc"
s = null // OK
```)

#kt-par[
  В отличие от Java, nullable типами могут быть и примитивные (Int, Long etc.).
  #comment[
    Впрочем, это довольно неэффективно, так как, в то время как Int, Char, и так
    далее транслируются в использование примитивов (int, char), nullable типы Int?,
    Char? --- в объектные Integer, Character и так далее, чтобы можно было
    присваивать им null. Это занимает больше места, больше времени и прочее.
    Аналогично происходит с lateinit var, которые под капотом nullable
  ]
  Поскольку NullPointerException --- одна из самых частых ошибок времени
  исполнения в Java, в Kotlin добавили специальных операторов для работы с
  nullable значениями:
]
- Non-null assertion
Если значение не null, то вернуть его, если null --- бросить ошибку.
#kt-ea(``` 
val s : String? = "abacaba"
s!!
```)
#kt-res(``` "abacaba"```, KtString)

#kt-ea(``` 
val s : String? = null
s!!
```)
#kt-runt-err(```
Exception in thread "main" java.lang.NullPointerException
  at test.TestKts.main(Test.kts:2)
```)
